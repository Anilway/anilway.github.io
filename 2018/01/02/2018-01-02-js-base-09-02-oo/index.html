<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.0 -->
    <script>
        window.materialVersion = "1.5.0"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Title -->
    
    <title>
        
            JS基础总结09:面向对象程序设计——创建对象的演变 | 
        
        Anilway
    </title>

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="format-detection" content="telephone=no"/>
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="Anilway">
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content=",JavaScript,JS基础总结">

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(window.oldVersion){var remove=window.oldVersion.reduce(function(p,c){return p||data.indexOf("/*"+c+"*/")!==-1},false);if(remove){lsloader.removeLS(key)}}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload,isJs){if(typeof cssonload==="boolean"){isJs=cssonload;cssonload=undefined}isJs=isJs||false;cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}code=code.split(versionString)[1];if(isJs){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload,isJs)}};lsloader.requestResource=function(name,path,cssonload,isJs){var that=this;if(isJs){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else{this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon1.png">
    <link rel="icon" sizes="192x192" href="/img/favicon1.png">
    <link rel="apple-touch-icon" href="/img/favicon1.png">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Anilway">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #222 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #222 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #222 !important;
  }

  .toTop {
    background: #222 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #222;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #222;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #222;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icon -->

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?ezyEvm8ST5CGfpA+kFFi1g==", true)</script>
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="JS基础总结09:面向对象程序设计——创建对象的演变 | Anilway">
    <meta property="og:image" content="http://yoursite.com/img/favicon1.png" />
    <meta property="og:description" content="">
    <meta property="og:article:tag" content="JavaScript"> <meta property="og:article:tag" content="JS基础总结"> 

    
        <meta property="article:published_time" content="Tue Jan 02 2018 00:00:00 GMT+0800" />
        <meta property="article:modified_time" content="Thu Jan 04 2018 12:46:04 GMT+0800" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="JS基础总结09:面向对象程序设计——创建对象的演变 | Anilway">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="http://yoursite.com/img/favicon1.png">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="http://yoursite.com" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/index.html",
    "headline": "JS基础总结09:面向对象程序设计——创建对象的演变",
    "datePublished": "Tue Jan 02 2018 00:00:00 GMT+0800",
    "dateModified": "Thu Jan 04 2018 12:46:04 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Anilway",
        "image": {
            "@type": "ImageObject",
            "url": "/img/touxiang.jpg"
        },
        "description": "Make yourself better!"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Anilway",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon1.png"
        }
    },
    "keywords": ",JavaScript,JS基础总结",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1、用Object实例创建对象"><span class="post-toc-text">1、用Object实例创建对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2、用字面量法创建对象"><span class="post-toc-text">2、用字面量法创建对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3、工厂模式"><span class="post-toc-text">3、工厂模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4、构造函数模式"><span class="post-toc-text">4、构造函数模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5、原型模式"><span class="post-toc-text">5、原型模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-1-基本概述"><span class="post-toc-text">5.1 基本概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-2-读取属性的方式"><span class="post-toc-text">5.2 读取属性的方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-原型的简写语法"><span class="post-toc-text">5.3 原型的简写语法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-原型模式的问题"><span class="post-toc-text">5.4 原型模式的问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6、混合模式"><span class="post-toc-text">6、混合模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7、动态原型模式"><span class="post-toc-text">7、动态原型模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8、寄生构造函数模式"><span class="post-toc-text">8、寄生构造函数模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9、稳妥构造函数模式"><span class="post-toc-text">9、稳妥构造函数模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        <!-- Custom Thumbnail -->
        <div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(https://t1.picb.cc/uploads/2017/11/29/bohRd.jpg)">
    
            <p class="article-headline-p">
                JS基础总结09:面向对象程序设计——创建对象的演变
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/touxiang.jpg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Anilway</strong>
        <span>1月 02, 2018</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    
        <button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">devices other</i>
    <span class="visuallyhidden">devices other</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button">
    <li class="mdl-menu__item">在其它设备中阅读本文章</li>
    
        <img src="https://pan.baidu.com/share/qrcode?w=246&h=246&url=http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/">
    
</ul>

    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/JS基础总结/">JS基础总结</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/JavaScript/">JavaScript</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=JS基础总结09:面向对象程序设计——创建对象的演变&url=http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/index.html&pic=http://yoursite.com/img/favicon1.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=JS基础总结09:面向对象程序设计——创建对象的演变&url=http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/index.html&via=Anilway" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <script src="\assets\js\APlayer.min.js"> </script><h2 id="1、用Object实例创建对象"><a href="#1、用Object实例创建对象" class="headerlink" title="1、用Object实例创建对象"></a>1、用Object实例创建对象</h2><p>一开始，人们会Object实例创建自定义对象：</p>
<pre><code class="javascript">var obj=new Object();
obj.name=&quot;Joun&quot;;
obj.job=&quot;teacher&quot;;
obj.sayName=function(){alert(this.name)};
</code></pre>
<h2 id="2、用字面量法创建对象"><a href="#2、用字面量法创建对象" class="headerlink" title="2、用字面量法创建对象"></a>2、用字面量法创建对象</h2><p>几年后，人们开始用字面量法创建对象：</p>
<pre><code class="javascript">var obj={
  name:&quot;Bob&quot;;
  job:&quot;Doctor&quot;;
  sayName:function(){alert(this.name)};
};
</code></pre>
<p>这样确实很方便，但是，如果我要为公司每个人建立人事信息档案，那按照上面的方式，每个人都要创建一次<code>name</code>、<code>job</code>等等属性，这样实在是太麻烦。</p>
<h2 id="3、工厂模式"><a href="#3、工厂模式" class="headerlink" title="3、工厂模式"></a>3、工厂模式</h2><p>于是，人们便想起来用函数把这个建立过程封装起来，这样以后就只要调用函数就可以了：</p>
<pre><code class="javascript">function person(name,job){
  var o=new Object();
  o.name=name;
  o.job=job;
  o.sayName=function(){alert(this.name)};
  return o;
}

//这样的话，以后我创建person，就只要调用函数，传参就可以了。
var Bob=person(&quot;Bob&quot;,&quot;Doctor&quot;);
var Anna=person(&quot;Anna&quot;,&quot;teacher&quot;);
</code></pre>
<p>这个模式有一个名字，叫做工厂模式，为什么呢？</p>
<pre><code class="javascript">//因为和工厂生产很类似
function person(name,job){
  //原料
  var o=new Object();
  //加工
  o.name=name;
  o.job=job;
  o.sayName=function(){alert(this.name)};
  //出厂
  return o;
}
</code></pre>
<p>工厂模式固然是好，可以无数次调用函数建立多个类似的对象。但是，创建的对象都只是object类型，如果我希望创建的对象属于person类型，就像Array、String等对象一样，以区分其他对象，在该模式下，就无法实现。也就是说，工厂模式没有解决对象识别问题。</p>
<h2 id="4、构造函数模式"><a href="#4、构造函数模式" class="headerlink" title="4、构造函数模式"></a>4、构造函数模式</h2><p>随着JS的发展，人们发展出这个新模式。</p>
<pre><code class="javascript">function Person(name,job){  //按照惯例，构造函数的函数名以大写字母开头
  this.name=name;
  this.job=job;
  this.sayName=function(){alert(this.name)};
}

//要创建Person的新实例，要用到new操作符
var Anna=new Person(&quot;Anna&quot;,&quot;teacher&quot;);
console.log(Anna instanceof Person);//true
console.log(Anna instanceof Object);//true
</code></pre>
<p>对于构造函数，我们对比前面的工厂模式，就发现：</p>
<ul>
<li>没有<code>o=new Object()</code>，即没有创建Object实例</li>
<li>直接将属性和方法赋给<code>this</code>对象</li>
<li>没有<code>return o</code>，即没有返回新对象</li>
</ul>
<p>这是因为有new操作符的帮助。你看，我们在创建Person对象的新实例的时候，没有直接调用构造函数，而是通过new操作符调用构造函数。以这种方式调用构造函数，就会经历：</p>
<ul>
<li>创建一个对象</li>
<li>this指向新对象（将构造函数的作用域赋给新对象）</li>
<li>为新对象添加属性</li>
<li>返回新对象</li>
</ul>
<p>这样，我们获得的就是Person对象的新实例。而且，这个实例是属于Person类型的。而对象是基于Object创建的，所以，这个实例同时又属于Object类型。</p>
<p>我们可以说：<strong>构造函数可用来创建特定类型的对象。</strong></p>
<p>至于为什么使用构造函数，就能创建一个对象类型(比如前面的Person对象的实例，使用<code>instanceof</code>，可以检测Anna属于Person类)。这个我也无法解释，你可以理解为JS的内部机制就是这样设计的。就像是，为什么使用<code>new</code>操作符就可以创建对象，返回对象一样，它的内部就是这样设计的。</p>
<p>对于构造函数可以创建特定类型的对象，我们可以类比理解：</p>
<pre><code class="javascript">//Array()、Object()、Function()等等这些都是构造函数
//我们要创建Object实例，就要用：
var obj=new Object();//var obj={};字面量法只是一种简写
//我们要创建新数组，也要用：
var arr=new Array();//var arr=[];字面量法只是一种简写
alert(arr instanceof Array);//true
alert(arr instanceof Object);//true
</code></pre>
<blockquote>
<p>我再来尝试解释一下，为什么构造函数可以创建一个特定类型的对象，而工厂模式就不行。</p>
<p>（你可以先把后面的原型、原型链看完之后再来看这个乱七八糟的解释。）</p>
<p>对于对象，都有<code>constructor</code>属性，该属性指向它的构造函数。对于工厂模式，它return出来的对象是调用Object()创建的，所以是指向Object的，并不指向那个封装函数。但是对于构造函数，是直接new 构造函数，所以，它的实例都是指向它们自己的构造函数的。</p>
<p>instanceof操作符，看它的英文意思：<code>A instanceof Fun()</code>A是函数Fun()的实例吗？<code>true /false</code></p>
<p>Anna和Bob都指向Person()，所以他们都是Person的实例，换句话说，他们都属于Person类型。</p>
<p>（暂时这样放着，再修改）</p>
</blockquote>
<p>构造函数和一般的函数没有区别，都是函数，只不过用来创建对象而已。但是为了构造函数，人们习惯于让函数名首字母大写。</p>
<p>构造函数解决了工厂模式的对象识别问题，但是构造函数自身也有问题：</p>
<p><strong>方法不能共用。每个方法都要在每个实例上重新创建一遍。</strong>（属性也是如此）（这个需要和后面的原型模式对比才能更好的理解）</p>
<blockquote>
<p>我不妨在这里解释一下先：</p>
<p>我们看例子：</p>
<pre><code class="javascript">function Person(name,age){
  this.name=name;
  this.age=age;
  this.sayName=function(){alert(this.name);};
}

var person1=new Person(&quot;Anna&quot;,26);
var person2=new Person(&quot;Bob&quot;,25);
console.log(person1);// {name: &quot;Anna&quot;, age: 26, sayName: function}
console.log(person2);// {name: &quot;Bob&quot;, age: 25, sayName: function}
</code></pre>
<p>也就是说，在构造函数模式下，其实例对象的属性和方法都会创建一遍（new操作符帮忙创建的）。</p>
<p>我们对比一下原型模式：</p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
Human.prototype.age=26;
Human.prototype.sayName=function(){alert(this.name);};

var human1=new Human();
var human2=new Human();
console.log(human1);// {}
console.log(human2);// {}
</code></pre>
<p>也就是说，在原型模式下，其实例对象本身就是个空的（没有自身的实例属性），实例对象是在共用原型对象里面的属性和方法，它们自身不会重新创建属性和方法。</p>
</blockquote>
<p>但是，每个属性的值都是不一样的，所以，每个实例重新创建一遍属性没有问题。比如：<code>name=&quot;Anna&quot;</code>和<code>name=&quot;Bob&quot;</code>。但是实例使用的方法都是一样的，比如<code>sayName()</code>方法，本来是可以共用的，无数个实例都各自创建一个是在是没必要，浪费计算机资源。</p>
<p>比如：</p>
<pre><code class="javascript">function Person(name,job){  
  this.name=name;
  this.job=job;
  this.sayName=function(){alert(this.name);};
  //可以理解为this.sayName=new Function(&#39;alert(this.name)&#39;);
}

var person1=new Person(&quot;Anna&quot;,&quot;teacher&quot;);
var person2=new Person(&quot;Bob&quot;,&quot;Doctor&quot;);

alert(person1.sayName==person2.sayName);//false 意味着指针指向不一样，它们是两个不同的函数
</code></pre>
<p>人们也想过一些治标不治本的方法：就是把方法单独提出来嘛</p>
<pre><code class="javascript">function Person(name,job){  
  this.name=name;
  this.job=job;
  this.sayName=sayName;//sayName包含一个sayName函数的指针
}
function sayName(){alert(this.name);};
var person1=new Person(&quot;Anna&quot;,&quot;teacher&quot;);
var person2=new Person(&quot;Bob&quot;,&quot;Doctor&quot;);
</code></pre>
<p>这样，person1和person2共享了在全局作用域中的<code>sayName()</code>函数。但是，<code>sayName()</code>在全局作用域中，原本可以被其他作用域中的函数之类的调用，现在却只能被区区某一类对象（是某一个构造函数下的对象实例）调用，这样对于全局作用于函数有些名不副实，有些大材小用，有些浪费。而且，如果有很多方法，就要定义多个全局作用域函数，都要放在构造函数外面，这样就没有封装性了。</p>
<h2 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h2><h3 id="5-1-基本概述"><a href="#5-1-基本概述" class="headerlink" title="5.1 基本概述"></a>5.1 基本概述</h3><p>对于共享，你一定还记得引用类型值的复制。（参见《JS高程》（第三版）P69）</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020100.PNG" alt=""></p>
<p>复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另<br>一个变量，如下面的例子所示：</p>
<pre><code class="javascript">var obj1 = new Object();
var obj2 = obj1;
obj1.name = &quot;Nicholas&quot;;
alert(obj2.name); //&quot;Nicholas&quot;
</code></pre>
</blockquote>
<p>如果我给obj1添加一点方法，那么obj2也可以共享。</p>
<pre><code class="javascript">var obj1 = new Object();
var obj2 = obj1;
obj1.name = &quot;Nicholas&quot;;
obj1.sayName=function(){alert(this.name);};
obj2.sayName(); //&quot;Nicholas&quot;
</code></pre>
<p>于是，人们又想到了原型。什么是原型呢？</p>
<p>我们创建的每一个函数，都有一个原型属性<code>prototype</code>，它是一个指针，指向一个对象，叫做原型对象。这个原型对象的属性和方法可以被该类型下所有的实例所共享。</p>
<p>比如：</p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
Human.prototype.age=26;
Human.prototype.sayName=function(){alert(this.name);};

var human1=new Human();
var human2=new Human();
alert(human1.name);    //CC
human1.sayName();      //CC
alert(human2.name);    //CC
human1.sayName();      //CC
</code></pre>
<p>原理如下图所示：</p>
<ul>
<li>每个函数都有原型属性<code>prototype</code>，这个原型属性的值原型对象里面有个<code>constructor</code>属性，指向构造函数</li>
<li>该类型下的每个对象实例有个_proto_属性，这个属性对脚本是不可见的。该属性指向原型对象，也就是说和<code>prototype</code>的地址值相等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/2018010201.PNG" alt=""></p>
<p>我们可以用代码描述更容易理解：</p>
<pre><code class="javascript">//因为函数也是对象（new Function()）;所以我们可以把Human构造函数看成对象：
var Human={
  prototype:{
    name:&quot;CC&quot;,
    age:26,
    sayName:function(){alert(this.name);};
  }
};

var human1={};
var human2={};
human1._proto_=Human.prototype;
human2._proto_=Human.prototype;
</code></pre>
<p>我们再用内存的方式理解一下：</p>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020102.PNG" alt=""></p>
<p>这不就是引用类型值的复制吗？是不是和一开始的那张图很类似，没错！原理就是这样的。</p>
<blockquote>
<p>所以，原型有动态特性。即：对原型对象做任何修改，都能立即反映在实例上。</p>
<p>因为实例是通过指针访问原型对象的。但是要注意，如果是重写原型对象又另说，后面在讲到原型的简写语法时会详解。</p>
<pre><code class="javascript">var friend=new Person();
Person.prototype.sayHi=function(){alert(&quot;Hi&quot;);};
friend.sayHi();//&quot;Hi&quot;
//这个例子想说，先创建了对象实例friend，这个时候还没有sayHi方法，接着给原型对象添加sayHi方法，friend实例就可以立即使用。这就是原型的动态特性。
</code></pre>
</blockquote>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">如何确定构造函数的原型指向和实例对象的隐式原型指向相同呢？换句话说，怎样确定它们都指向同一个原型对象？</div>

<blockquote>
<p>用下面两种方法：</p>
<p><span style="color:purple;font-weight:bold;"> - <code>isPrototypeOf()</code>：用于判断构造函数的原型指向和实例对象的隐式原型指向是否相同。</span></p>
<pre><code class="javascript">//比如上面的例子
alert(Human.prototype.isPrototypeOf(human1));//true
alert(Human.prototype.isPrototypeOf(human2));//true
</code></pre>
<p><span style="color:purple;font-weight:bold;">- <code>Object.getPrototypeOf()</code>：可以返回对象的隐式原型指针（ES5新增）</span></p>
<pre><code class="javascript">alert(Object.getPrototypeOf(human1)==Human.prototype);//true
alert(Object.getPrototypeOf(human2)==Human.prototype);//true
alert(Object.getPrototypeOf(human1).name);//CC
alert(Object.getPrototypeOf(human2).name);//CC 这里是human2的_proto_指向的原型对象里面的&gt; name属性的值
</code></pre>
</blockquote>
<p>现在回过头来想一想，在原型模式下，是实例和原型对象之间的连接，和之前构造函数模式中的实例和构造函数的连接不同。</p>
<p>然后，我们也可以理解，为什么原型模式下的实例，实际上是一个空对象了：</p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
Human.prototype.age=26;
Human.prototype.sayName=function(){alert(this.name);};

var human1=new Human();
var human2=new Human();
console.log(human1);// {}
console.log(human2);// {}
</code></pre>
<p>因为实例的属性和方法是引用的原型对象里面的。实例对象本身是不具备实例属性和方法的，当然你自己设定又另说。</p>
<p>说到自己设定实例属性和方法。如果它们和原型对象里面的属性和方法重名。在实例对象调用该属性方法时，就会屏蔽原型对象的，而显示自己的。</p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
var human1=new Human();
var human2=new Human();
human2.name=&quot;Bob&quot;;
human2.age=25;//你也可以给实例添加原型对象没有的属性和方法
alert(human1.name);//CC
alert(human2.name);//Bob
</code></pre>
<blockquote>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、 Array、 String，等等）都在其构造函数的原型上定义了方法。 </p>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。 比如：</p>
<pre><code class="javascript">Array.prototype.sayHi=function(){alert(&quot;Hi&quot;);};
</code></pre>
<p>但是随意修改原生构造函数的原型不好，容易引起错误，不建议修改。</p>
</blockquote>
<h3 id="5-2-读取属性的方式"><a href="#5-2-读取属性的方式" class="headerlink" title="5.2 读取属性的方式"></a>5.2 读取属性的方式</h3><p>说到这呢，就要说说JS搜索实例对象的属性的方式：</p>
<blockquote>
<p>先搜索实例本身，如果有就返回该属性值。如果没有，再搜索原型对象，如果有，就返回该属性值。如果没有就真没有了。</p>
</blockquote>
<p>比如上面的例子：当代码读取<code>human1.name</code>，先搜索human1对象本身，没有name属性，再搜索原型对象，有name属性，为CC，返回CC。当代码读取<code>human2.name</code>，先搜索human2对象本身，诶！有name属性，Bob，返回Bob，完毕。</p>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">对实例对象调用属性，会有个疑问，这个属性到底是实例对象的还是原型对象的呢？</div>

<blockquote>
<p><span style="color:purple;font-weight:bold;">- <code>hasOwnProperty()</code>：检测属性是否为实例属性（字面意思是：是has——我的Own——属性Property？）</span></p>
<pre><code class="javascript">//接前面的例子
alert(human1.hasOwnProperty(&quot;name&quot;));//false
alert(human2.hasOwnProperty(&quot;name&quot;));//true
</code></pre>
<p><span style="color:purple;font-weight:bold;">- <code>Object.keys()</code>：获取对象所有可枚举的实例属性，返回一个包含所有可枚举的字符串的数组</span></p>
<pre><code class="javascript">console.log(Object.keys(human1));//&quot;&quot;
console.log(Object.keys(human2));//&quot;name,age&quot;
delete human2.name;
console.log(Object.keys(human2));//&quot;age&quot;
</code></pre>
<p><span style="color:purple;font-weight:bold;">- <code>Object.getOwnPropertyNames()</code>：获取所有的实例属性，无论是否枚举都会获取</span></p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
var str=Object.getOwnPropertyNames(Human.prototype);
alert(str);//&quot;consrtuctor,name&quot;
//这个里面constructor就是不可枚举的属性
//另外不要有思维误区，属于这个实例本身的属性就是实例属性。Human.prototype也是实例对象，它是Object的实例，因为任何对象都是Object的实例。所以，不仅仅是构造函数的实例可以用这个方法，构造函数的原型也可以用这个方法。
</code></pre>
<p><span style="color:purple;font-weight:bold;">- <code>hasPrototypeProperty()</code>：检测属性是否为原型属性（字面意思就是：是has——原型Prototype——属性Property？）</span></p>
<pre><code class="javascript">alert(human1.hasPrototypeProperty(&quot;name&quot;));//true
alert(human2.hasPrototypeProperty(&quot;name&quot;));//false
</code></pre>
<p><span style="color:purple;font-weight:bold;">- <code>in操作符</code> ：如果<code>in操作符</code>单独使用，可以检测实例对象能否访问该属性，无论该属性来自实例还是原型。</span></p>
<p>（还有一种是<code>for-in</code>循环使用）</p>
<pre><code class="javascript">alert(&quot;name&quot; in human1);//true
alert(&quot;name&quot; in human2);//true name来自实例
alert(&quot;age&quot; in human2);//true
delete human2.name；//删除human2实例中的name属性
alert(human2.name);//CC
alert(&quot;name&quot; in human2);//true name来自原型
</code></pre>
<p>顺便说一下，使用<code>for-in</code>循环时，返回的是所有对象可以访问的、可枚举（enumerable）的属性，所以既有原型属性，也包括实例属性。但是，不包括被实例属性屏蔽的同名原型属性（同名可枚举的实例属性会被返回）。</p>
</blockquote>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">为什么对象实例不能重写原型中的值？</div>

<blockquote>
<blockquote>
<p>（————以下是第二次解释————）</p>
</blockquote>
<p><code>_proto_</code>是关键，它就像开关一样，是实例访问原型对象的开关，只有在搜索原型属性的时候才会开启。</p>
<p>举个例子你就明白了：</p>
<pre><code class="javascript">Person.prototype.name=&quot;Anna&quot;;
var person=new Person();
person.name;//这是访问原型中的name属性。这是_proto_在发挥作用。
person.name=&quot;Bob&quot;;//这不是对原型中的name属性重新赋值，而是在创建实例属性name
</code></pre>
<p>一开始，实例对象里面没有name属性。我来调用<code>person.name</code>，代码执行的是：</p>
<ul>
<li>先是<code>person.name</code>，在实例对象自身寻找name属性，没有。这个时候<code>_proto_</code>相当于是关闭的</li>
<li>再是<code>person._proto_name</code>，在原型对象里面寻找name属性，由于<code>_proto_</code>是个隐形属性，是看不见的，这个时候，<code>_proto_</code>相当于是开着的。</li>
</ul>
<p>而<code>person.name=&quot;Bob&quot;</code>并没有调动起<code>_proto_</code>属性，person和原型对象没有连接起来，就是建立自身的属性，和普通的给对象建立属性是一样的，比如：</p>
<pre><code class="javascript">var person={};
person.name=&quot;Bob&quot;
</code></pre>
<p>所以，当我们抱着更改name的值的想法来给name重新赋值的时候，<code>_proto_</code>没有发挥作用，实例和原型没有连接，实际上这是在给实例对象创建实例属性。所以，对象实例不能重写原型中的值。</p>
<blockquote>
<p>（————以下是第一次解释————）</p>
</blockquote>
<p>在《JS高程》（第三版）P150页原文是这么说的：</p>
<blockquote>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。 </p>
</blockquote>
<p>也就是说，我们可以通过对象实例来访问原型对象中的属性，但是我们不能修改原型对象中的属性。如果我们为原型对象设置同名属性，那么设置的这个属性是对象实例自身的属性，而不是对原&gt;型对象中的同名属性进行修改。而且在访问的时候，会屏蔽原型对象中的同名属性。</p>
<p>还是用前面的例子：</p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
var human1=new Human();
var human2=new Human();
human2.name=&quot;Bob&quot;;//设定的这个name属性现在是human2自己的实例属性了
alert(human1.name);//CC
alert(human2.name);//Bob
//我们再来看看这两个实例对象本身
console.log(human1);//{}
console.log(human2);//{name:&quot;Bob&quot;}
</code></pre>
<p>一点疑问：<a href="https://segmentfault.com/q/1010000006671767" target="_blank" rel="external">这个例子为什么就改变原型对象的值了呢？作何解释</a></p>
<pre><code class="javascript">function Person(name,age,job){
   this.name=name;
   this.age=age;
   this.job=job;
}
Person.prototype.friends=[&#39;shell&#39;,&#39;dom&#39;,&#39;bom&#39;];
Person.prototype.color=&#39;red&#39;;
var person2=new Person(&#39;Mark&#39;,29,&#39;teach&#39;);
person2.color=&#39;green&#39;;
console.log(person2.color);//green
var person1=new Person(&#39;jack&#39;,19,&#39;stu&#39;);
console.log(person1.color);//red

person1.friends.push(&#39;window&#39;);
console.log(person1.friends);//[&quot;shell&quot;, &quot;dom&quot;, &quot;bom&quot;, &quot;window&quot;]
console.log(person2.friends);//[&quot;shell&quot;, &quot;dom&quot;, &quot;bom&quot;, &quot;window&quot;]
</code></pre>
<blockquote>
<p>你还记得引用类型值的存储方式吗？（参见《JavaScript高级程序设计》（第三版）P68）</p>
<p>friends是一个指针，它的真正的值是一个指针值，或者叫地址值，我们假设这个值为0x21。然后再根据这个地址，找到储存在堆内存中的对象[“shell”, “dom”, “bom”]。</p>
<p>也就是：friends=0x21————&gt;对象。</p>
<p>一开始，为friends=0x21————&gt;[“shell”, “dom”, “bom”];</p>
<p>然后，你person1.friends.push(‘window’);之后，就变成：</p>
<p>friends=0x21————&gt;[“shell”, “dom”, “bom”, “window”];</p>
<p>friends的地址值是没有变化的。</p>
<p>你用person1.friends和person2.friends前后访问的都是这个地址值。</p>
</blockquote>
</blockquote>
<h3 id="5-3-原型的简写语法"><a href="#5-3-原型的简写语法" class="headerlink" title="5.3 原型的简写语法"></a>5.3 原型的简写语法</h3><p>我们回到一开始，通过原型模式创建对象：</p>
<pre><code class="javascript">function Human(){};
Human.prototype.name=&quot;CC&quot;;
Human.prototype.age=26;
Human.prototype.sayName=function(){alert(this.name);};
</code></pre>
<p>每次都要写一下实在是太麻烦了，于是人们就想到：</p>
<pre><code class="javascript">function Human(){};
Human.prototype={
  name:&quot;CC&quot;,
  age:26,
  sayName:function(){alert(this.name);}
}
</code></pre>
<p>可是，这么做有个问题，就是我们以字面量的形式创建了一个新对象，原型指针指向这个新对象，而不是原来的原型对象了。</p>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">为什么原型指针指向了新对象，而不是原来的原型对象？</div>

<blockquote>
<p>你还记得最开始讲的用字面量创建对象是用Object实例创建对象的简写形式吧？</p>
<pre><code class="javascript">var obj=new Object();//等同于obj={}
</code></pre>
<p>所以，上面的原型对象的偷懒写法实际上就是：</p>
<pre><code class="javascript">function Human(){};
Human.prototype=new Object();//新原型对象是通过Object构造函数new出来的，
                            //所以，其constructor属性指向Object，不指向Human
Human.prototype.name=&quot;CC&quot;;
Human.prototype.age=26;
Human.prototype.sayName=function(){alert(this.name);};
</code></pre>
<p>当我们创建一个函数，就会默认给这个函数的原型创建一个原型对象，而且，里面会有默认的<code>constructor</code>属性指向原型对象。</p>
<p>但是现在，用偷懒的写法，原型指针就指向一个新对象了。</p>
<p>我们再用图来解释一下：</p>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020104.PNG" alt=""></p>
<p>对于原原型对象，如果还存在，就是图中的情况，它存在，但是无法调用它，它的<code>constructor</code>还指向Human构造函数呢。也许，就被垃圾回收了，我目前还不得而知。</p>
</blockquote>
<p>从图上可以很容易理解，这个时候，新对象的<code>constructor</code>指向它的构造函数Object，但是不指向Human了。所以：</p>
<pre><code class="javascript">function Human(){};
Human.prototype={
  name:&quot;CC&quot;,
  age:26,
  sayName:function(){alert(this.name);}
}

var human1=new Human();
alert(human1 instanceof Object);    //true
alert(human1 instanceof Human);     //false
alert(human1.constructor==Object);  //true
alert(human1.constructor==Human);   //false
</code></pre>
<p>在这里，我们可以回答一下前面构造函数模式中的问题：</p>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">为什么构造函数就可以创建一个特定类型的对象，它的实例用 instanceof 检测属于它的构造函数</div>

<blockquote>
<p><strong>就是因为这个构造函数的实例的<code>constructor</code>属性都指向该构造函数啊。</strong></p>
<p><code>consturctor</code>原型属性就像是DNA一样，可以确定对象和构造函数的亲子关系，只要我们检测到对象和构造函数的<code>constructor</code>是一样的，都指向这个构造函数，那么该对象就是该构造函数的实例，该对象属于该构造函数类别。</p>
<p>（思考：如果我给对象实例添加一个同名的constructor属性，而且指向其他的构造函数，会怎么样呢？）</p>
<p>这么来想：某个对象obj，我们不知道它的构造函数，通过调用</p>
<pre><code class="javascritp">alert(obj.constructor);
</code></pre>
<p>得到它的构造函数，假设是Fun()；那么，obj就是Fun的实例，对吧！</p>
<p>而<code>instanceof</code>操作符字面的意思就是：属于……的实例。它就是基于<code>instanceof</code>来检测的所以：</p>
<pre><code class="javascript">alert(obj instanceof Fun);//true
</code></pre>
<p>为什么构造函数就可以创建一个特定类型的对象？</p>
<p>就是因为构造函数会有一个constructor原型属性，它的实例都可以访问这个属性，指向这个构造函数，所以，这些对象实例都是属于这个构造函数的特定对象。既然如此，假设这个构造函数叫Fun，那么这些对象实例就都属于Fun类罗。</p>
<p>同样的道理，Array()的数组实例都属于Array类罗！</p>
</blockquote>
<p>我们再回过头来看偷懒的原型写法，会导致<code>constructor</code>不指向自己的构造函数，而是指向Object构造函数，所以，如果该属性真的很重，我们只要重新设定一下就可以了。</p>
<pre><code class="javascript">function Human(){};
Human.prototype={
  constructor:Human,//注意这里是对constructor重新赋值哦！
  name:&quot;CC&quot;,
  age:26,
  sayName:function(){alert(this.name);}
}
</code></pre>
<p>用图说明就是：</p>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020105.PNG" alt=""></p>
<p>要注意一点的是，这种方式重设<code>constructor</code>是可以枚举的，也就是其[[Enumerable]]会设为true，原生的<code>constructor</code>是不可枚举的。所以，如果考虑到对ES5的JS引擎的兼容性，可以用<code>Object.defineProperty()</code>设定一下。</p>
<pre><code class="javascript">Object.defineProperty(Human.prototype,&quot;constructor&quot;,{
  enumerable:false,
  value:Human
});
</code></pre>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">用偷懒的方式写原型对象，为什么不能先创建实例，再写原型对象？</div>

<blockquote>
<p>我们来看这个流程：</p>
<ul>
<li>首先，我们创建构造函数：<code>function Fun(){};</code>这时，其prototype指向默认的原型对象。</li>
<li>然后先创建其实例：<code>var fun=new Fun();</code>这个时候fun的隐式原型<code>_prop_</code>是指向默认原型对象的。</li>
<li>然后再重写原型对象：<code>Fun.prototype={……};</code>这个时候prototype指向新的原型对象了。而实例还指向在默认原型对象。</li>
</ul>
<p>问题就在于，我们把属性和方法添加在新原型对象中，而调用实例的时候，还是从原来的原型对象中搜索属性，肯定找不到我们设定的属性，所以会出错。</p>
<p>下面来看看具体的例子：</p>
<pre><code class="javascript">function Person(){}
var friend = new Person();
Person.prototype = {
  constructor: Person,
  name : &quot;Nicholas&quot;,
  age : 29,
  job : &quot;Software Engineer&quot;,
  sayName : function () {
          alert(this.name);
    }
};
friend.sayName(); //error
</code></pre>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020106.png" alt=""></p>
</blockquote>
<h3 id="5-4-原型模式的问题"><a href="#5-4-原型模式的问题" class="headerlink" title="5.4 原型模式的问题"></a>5.4 原型模式的问题</h3><p>其最大的问题是由其共享本性造成的。</p>
<p>原型中的属性是被许多实例所共享的。如果属性的值是函数、值类型都没有问题，如果是引用类型值的属性，问题就很突出了。比如：</p>
<pre><code class="javascript">function Person(){}
Person.prototype = {
  constructor: Person,
  name : &quot;Nicholas&quot;,
  age : 29,
  job : &quot;Software Engineer&quot;,
  friends : [&quot;Shelby&quot;, &quot;Court&quot;],
  sayName : function () {
      alert(this.name);
  }
};
var person1 = new Person();
var person2 = new Person();
person1.friends.push(&quot;Van&quot;);
alert(person1.friends); //&quot;Shelby,Court,Van&quot;
alert(person2.friends); //&quot;Shelby,Court,Van&quot;
alert(person1.friends === person2.friends); //true
</code></pre>
<h2 id="6、混合模式"><a href="#6、混合模式" class="headerlink" title="6、混合模式"></a>6、混合模式</h2><p>为了解决上面的问题，人们就想到：<strong>组合使用构造函数模式和原型模式。</strong></p>
<p>对于共享的部分，就放在原型里面，大家一起共用，比如：<code>sayName()</code>方法。对于不想共享的部分，比如：name、age这样个性化的属性，就放在构造函数里面，这样在创建实例时，就会给每个实例创建一份，成为实例自身的实例属性。而且。这样的话，还可以传递参数，很方便。</p>
<blockquote>
<p>这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的放法。可以说，这是用来定义引用类型的一种默认模式。</p>
</blockquote>
<pre><code class="javascript">function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
person1.friends.push(&quot;Van&quot;);
alert(person1.friends); //&quot;Shelby,Count,Van&quot;
alert(person2.friends); //&quot;Shelby,Count&quot;
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
</code></pre>
<h2 id="7、动态原型模式"><a href="#7、动态原型模式" class="headerlink" title="7、动态原型模式"></a>7、动态原型模式</h2><p>人们也在想，原型对象总是在构造函数外面，可不可以把原型也放在构造函数里面呢？这样更具有封装性。</p>
<p>动态原型模式就可以解决这个问题，它把所有的信息都放在构造函数中。</p>
<blockquote>
<p>特点是初始化原型。</p>
</blockquote>
<p>我们来看个例子：</p>
<pre><code class="javascript">function Person(name, age, job){
//属性
    this.name = name;
    this.age = age;
    this.job = job;
//方法
    if (typeof this.sayName != &quot;function&quot;){ //关键部分
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}
var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);//创建实例时会调用到构造函数
friend.sayName();
</code></pre>
<p>当我们第一次调用构造函数时，构造函数里面就会判断<code>this.sayName</code>是不是函数类型，如果不是，就在原型里面添加<code>sayName</code>方法。我们初次调用构造函数的时候原型里面没有添加这个方法啊，<code>this.sayName</code>肯定不是函数类型，于是就像原型中添加了该方法。这就是初始化。</p>
<blockquote>
<p>要注意啊！在调用构造函数时才会调用那段判断代码。也就是只有在创建实例时，使用<code>new</code>操作符调用构造函数时，才会执行这段代码。在创建首个实例时，原型会初始化。之后创建实例就不用初始化了。</p>
<p>也就是说，在我们写完构造函数，还没有创建实例时，构造函数中的原型对象里面是空的，没有我们自己定义的方法。（不过默认的一些还是有的），只有在第一次调用构造函数之后，原型里面才装满了我们自定义的方法。</p>
<p>而不是在实例调用时执行那段代码！想清楚！</p>
</blockquote>
<p>再之后再次创建实例时，构造函数里面也会判断，<code>this.sayName</code>是不是函数类型，一看，诶！是函数类型的，说明向原型添加过该方法了，就不会再添加，直接在原型里面调用该方法。</p>
<p>这就是动态原型模式。通过初始化原型的方式，将原型也封装在构造函数里面。</p>
<blockquote>
<p>换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 </p>
</blockquote>
<p>如果我们有多个方法需要初始化，也只要使用一个属性或方法进行判断就可以了，不必写一大堆<code>if</code>判断，比如：</p>
<pre><code class="javascript">if (typeof this.sayName != &quot;function&quot;){ 
  Person.prototype.sayName = function(){alert(this.name);};
  Person.prototype.sayAge = function(){alert(this.age);};
  Person.prototype.sayJob = function(){alert(this.job);};
}

//也可以用原型简写的语法方式
if (typeof this.sayName != &quot;function&quot;){ 
  Person.prototype={
    constructor:Person,//如果不想枚举，也可以用Object.defineProperty()设定
    sayName: function(){alert(this.name);},
    sayAge: function(){alert(this.age);},
    sayJob: function(){alert(this.job);}
  }
}
</code></pre>
<h2 id="8、寄生构造函数模式"><a href="#8、寄生构造函数模式" class="headerlink" title="8、寄生构造函数模式"></a>8、寄生构造函数模式</h2><p>我们来想想这种情况：</p>
<p>假设我们想为纯数字数组添加一个方法，比如求数组所有元素的和，且叫这个方法为add，让新创建的数组都可以使用这个方法。怎么办？</p>
<p>如果单纯用函数的话，倒是可以在全局作用域创建<code>add()</code>函数。比如：</p>
<pre><code class="javascript">function add(arr){
  var sum=0;
  for(var i=0;i&lt;arr.length;i++){
    sum+=arr[i];
  }
  return sum;
}
</code></pre>
<p>但是，现在我们想要为数组添加这样的方法啊！可不是单独的求和函数。</p>
<p>如果我们在<code>Array()</code>数组构造函数的原型添加这个方法<code>Array.prototype.add=function(){……}</code>，这样不太好。因为原生构造函数是定义好的，随便添加，可能会引起想不到的错误，比如，不小心重写了同名属性，比如兼容问题等等。</p>
<p>所以，这种情况就是：<strong>我想在不改变原来的构造函数的原型的情况下，给对象添加一些属性、方法。</strong></p>
<p>怎么办？</p>
<p>聪明的人类想到了寄生构造函数模式。</p>
<ul>
<li>我们构造一个空的构造函数</li>
<li>然后在这个构造函数内，创建目标对象的实例，并添加属性和方法</li>
<li>最后return出这个实例对象</li>
</ul>
<p><strong>听起来有点像代孕妈妈肚子里怀了别人的孩子，生出来的也是别人的孩子，和自己在DNA上没有血缘关系。</strong></p>
<p>我们来一探究竟。看个实际的例子：</p>
<pre><code class="javascript">function Person(name, age, job){
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function(){
      alert(this.name);
  };
  return o;
}
var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
friend.sayName(); //&quot;Nicholas&quot;
</code></pre>
<p>乍一看，这个构造函数的代码和工厂模式的代码很像，没错，一模一样。但是现在Person是构造函数，请用对待构造函数的眼光对待它。</p>
<blockquote>
<p><strong>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。</strong> </p>
</blockquote>
<p>也就是说，如果构造函数Person的末尾没有添加<code>return o</code>，返回的还是构造函数自己的实例，但是现在不一样了，添加了返回值为<code>o</code>，那么返回的就是Object的实例。</p>
<p>我们每次调用Person创建新对象实例，创建的不是Person类别的了，创建的是Object类的实例。</p>
<blockquote>
<p>所以，<strong>不能依赖instanceof来确定对象的类型。</strong></p>
</blockquote>
<p>因为构造函数里面是<code>var o=new Object()</code>，所以，返回出来的对象，<code>friend._proto_.constructor</code>是指向Object的，不是指向Person的，前面说过了，<code>constructor</code>就是DNA，它指向谁，这个实例就属于谁，所以，用<code>instanceof</code>检测是属于Object的，但是不属于Person。</p>
<p>但是，这个friend对象确实是通过Person <code>new</code>出来的啊。所以，在这里不能依赖<code>instanceof</code>检测对象的类型。</p>
<p>接着，我们再回到一开始的例子，给数组添加求和方法，就可以用寄生构造函数模式解决：</p>
<pre><code class="javascript">function Xarr(){
  //创建数组
  var arr=new Array();
  arr.push.apply(arr, arguments);//将参数添加到arr数组作为数组元素
  //给数组添加方法
  arr.add=function(){
      var sum=0;
      for(var i=0;i&lt;this.length;i++){
          sum+=this[i];
      };
      return sum
  }
  //返回数组
  return arr;
}

var arr1=new Xarr(1,2,3,4,5,6,7,8,9,10);
var arr2=new Xarr(40,5,1);
console.log(arr1.add());//55
console.log(arr2.add());//46

console.log(arr1 instanceof Array);     //true
console.log(arr1 instanceof Xarr);      //false
console.log(arr1.constructor==Array);   //true
console.log(arr1.constructor==Xarr);    //false
</code></pre>
<p>现在对于寄生构造函数模式，现在就基本上理解了吧。</p>
<p>但是，在我心里总有一些疑问没有解决，就像19世纪物理学头上的三朵乌云一样。</p>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">为什么一定要用new来调用构造函数呢？</div>

<pre><code class="javascript">function Person(name, age, job){
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function(){
      alert(this.name);
  };
  return o;
}
</code></pre>
<p>恩！你其实想说的是用new调用构造函数多此一举吧。因为在前面构造函数模式里面讲过用new调用构造函数的作用是：</p>
<ul>
<li>创建一个对象</li>
<li>this指向新对象（将构造函数的作用域赋给新对象）</li>
<li>为新对象添加属性</li>
<li>返回新对象</li>
</ul>
<p>但是这个构造函数里面自己都创建了新对象：<code>var o=new Object()</code>，而且结尾<code>return o</code>了。所以，用new就有点多此一举了。</p>
<p>但这里使用<code>new</code>操作符，就是为了调用构造函数，去创建实例。至于new操作符帮我们创建对象和return对象，就理解为被我们自己主动在构造函数里面的<code>var o = new Object()</code>、<code>return o</code>覆盖了。</p>
<div style="padding:5px;border:gray 2px solid;border-radius:5px; background:gray;color:white">这个方面的疑惑解决了，我们再往下想，为什么一定非要把Person当做构造函数去用，new出一个实例出来？我们直接把Person当做工厂模式中的函数来用也可以啊！寄生构造函数可以做的工作，工厂模式也能实现；那这种寄生构造函数存在有什么意义？所以，好处在哪里？请说服我！！！</div>

<p>我想，唯一的好处就是保证代码的优雅型性吧！让别人一看，就知道这是在构造一个新的对象类型的实例。</p>
<p>高程书中的原话是：</p>
<blockquote>
<p><strong>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。</strong></p>
<p>“<strong>它们又是用在什么样的情境下呢？</strong>”至于这个问题。书里也给出了明确的回答：“<strong>我们建议在可以使用其他模式的情况下，不要使用这种模式。</strong>”</p>
</blockquote>
<p>书里说可以在特殊情况下用来为对象创建构造函数。至于是什么特殊情况，大概是不能用其他模式的情况下吧。</p>
<p>看看这里的吐槽，了解了解就行了。<a href="https://www.zhihu.com/question/39363213" target="_blank" rel="external">JavaScript 中工厂模式与寄生构造函数模式有哪些不同？</a></p>
<h2 id="9、稳妥构造函数模式"><a href="#9、稳妥构造函数模式" class="headerlink" title="9、稳妥构造函数模式"></a>9、稳妥构造函数模式</h2><p>处于安全方面的考虑，一些上古时代的老年人发明了稳妥构造函数模式。</p>
<p>稳妥构造函数模式的特点：</p>
<ul>
<li>没有公共属性</li>
<li>不用<code>new</code>操作符调用构造函数</li>
<li>不使用this</li>
</ul>
<p>来看个实际的例子：</p>
<pre><code class="javascript">function Person(name, age, job){
  //创建要返回的对象
  var o = new Object();
  //可以在这里定义私有变量和函数

  //添加方法
  o.sayName = function(){
      alert(name);
  };
  //返回对象
  return o;
}

//注意，在以这种模式创建的对象中， 除了使用 sayName()方法之外，没有其他办法访问 name 的值。可以像下面使用稳妥的 Person 构造函数。
var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
friend.sayName(); //&quot;Nicholas&quot;
</code></pre>
<p>我不想说什么，就引用高程中的原话吧：</p>
<blockquote>
<p>这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境——例如,ADsafe（<a href="www.adsafe.org">www.adsafe.org</a>）和 Caja（<a href="http://code.google.com/p/google-caja/" target="_blank" rel="external">http://code.google.com/p/google-caja/</a>）提供的环境——下使用。 </p>
</blockquote>
<p>其实我想吐槽的，造这么高深的名词：稳妥构造函数模式。其实就是把对象封装在函数里面使用。而且不使用<code>new</code>操作符，不就是当做一般的函数来使用的吗？只不过没有给对象设定属性，只是设定了方法，把参数传进去罢了。</p>
<p>对于上面的<code>friend</code>对象，它自己其实只有一个实例方法，无论是实例对象本身还是它的构造函数的原型都没有我们人为定义的其他属性或方法。我们当然是没有其他的办法去访问其name值啊，除了使用<code>sayName()</code>方法之外。</p>
<p>其实吧，就当做一般的函数去理解还直接一些，不必搞的这么复杂。</p>
<p>以上，就是我目前对创建对象的认知！</p>
<p>我们原型链见！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020107.png" target="_blank" rel="external">查看大图</a></p>
<p><img src="https://raw.githubusercontent.com/Anilway/anilway.github.io/master/post_img/201801020107.png" alt=""></p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #222;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load"> 
    <button class="disqus_click_btn" style="display: none">阅读评论（请确保 disqus 可以正常加载）</button>
</div>

<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/01/02/2018-01-02-js-base-09-02-oo/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/ls-javascript" id="disqus-lazy-load-script">
    $.ajax({
        url: 'https://disqus.com/next/config.json',
        timeout: 4000,
        type: 'GET',
        success: (function() {
            var d = document;
            var s = d.createElement('script');
            s.src = '//anilway.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
            $('.btn_click_load').css('display','none');
        })(),
        error: function() {
          $('.btn_click_load').css('display','block');
        }
    });
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//anilway.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
  	

</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/01/08/2018-01-08-js-base-09-03-oo/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/12/31/2017-12-31-文本矩阵简述-V1.0/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header1.jpg);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/touxiang.jpg" alt="Anilway's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        更多
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto: hanway.robot@foxmail.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
                <li>
                    <a href="https://anilway.gitbooks.io/-javascript/content/" target="_blank" title="电子书">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">book</i>
                        
                        电子书
                    </a>
                </li>
            
                <li>
                    <a href="https://anilway.gitbooks.io/-javascript/content/" target="_blank" title="网址导航">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">tab</i>
                        
                        网址导航
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2018/04/">四月 2018<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/01/">一月 2018<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/12/">十二月 2017<span class="sidebar_archives-count">17</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/11/">十一月 2017<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/09/">九月 2017<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/JS基础入门/">JS基础入门<span class="sidebar_archives-count">20</span></a></li><li><a class="sidebar_archives-link" href="/categories/JS进阶/">JS进阶<span class="sidebar_archives-count">13</span></a></li><li><a class="sidebar_archives-link" href="/categories/其他/">其他<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/小技巧/">小技巧<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/旁征博引/">旁征博引<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/编程工具/">编程工具<span class="sidebar_archives-count">2</span></a>
            </ul>
        </li>
        
            <li class="divider"></li>
        
    

    <!-- Pages  -->
    
        <li>
            <a href="/about/index.html" title="关于我">
                
                关于我
            </a>
        </li>
        
    
        <li>
            <a href="/timeline" title="时间轴">
                
                时间轴
            </a>
        </li>
        
    
        <li>
            <a href="/tags" title="标签云">
                
                标签云
            </a>
        </li>
        
    
        <li>
            <a href="/links" title="友链接">
                
                友链接
            </a>
        </li>
        
    
        <li>
            <a href="/gallery" title="图片集">
                
                图片集
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/Anilway" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;2016&nbsp;-<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Anilway
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?wgjW/HuQG9JDgvPDPoRAng==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>









   <!-- 使用 DISQUS js 代码 -->






<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
